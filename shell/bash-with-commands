#!/usr/bin/env bash
#
#                                                 .___
#   ____  ____   _____   _____ _____    ____    __| _/______
# _/ ___\/  _ \ /     \ /     \\__  \  /    \  / __ |/  ___/
# \  \__(  <_> )  Y Y  \  Y Y  \/ __ \|   |  \/ /_/ |\___ \
#  \___  >____/|__|_|  /__|_|  (____  /___|  /\____ /____  >
#      \/            \/      \/     \/     \/      \/    \/
#
# Boilerplate for creating a bash program with commands.
#
# Copyright (c) 2015 William Melody â€¢Â hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

# Treat unset variables and parameters other than the special parameters â€˜@â€™ or
# â€˜*â€™ as an error when performing parameter expansion. An error message will be
# written to the standard error, and a non-interactive shell will exit.
#
# This requires using parameter expansion to test for unset variables.
#
# http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
#
# Examples
# ========
#
# Array:
#
#   ${some_array[@]:-}
#   ${some_array[*]:-}
#   ${some_array[0]:-}
#
# Postitional variables:
#
#   ${1:-alternative} # when a default value can be sepecified
#   ${2:-}            # when the desired alternative is a blank / null
#
# Short form: set -u
set -o nounset

# Exit immediately if a pipeline returns non-zero.
#
# NOTE: this has issues. When using read -rd '' with a heredoc, the exit
# status is non-zero, even though there isn't an error, and this setting
# then causes the script to exit. read -rd '' is synonymous to read -d $'\0',
# which means read until it finds a NUL byte, but it reaches the EOF (end of
# heredoc) without finding one and exits with a 1 status. Therefore, when
# reading from heredocs with set -e, there are three potential solutions:
#
# Solution 1. set +e / set -e again:
#
# set +e
# read -rd '' variable <<EOF
# EOF
# set -e
#
# Solution 2. <<EOF || true:
#
# read -rd '' variable <<EOF || true
# EOF
#
# Solution 3. Don't use set -e or set -o errexit at all.
#
# More information:
#
# https://www.mail-archive.com/bug-bash@gnu.org/msg12170.html
#
# Short form: set -e
set -o errexit

# Return value of a pipeline is the value of the last (rightmost) command to
# exit with a non-zero status, or zero if all commands in the pipeline exit
# successfully.
set -o pipefail

# Set IFS to just newline and tab at the start
#
# http://www.dwheeler.com/essays/filenames-in-shell.html
IFS="$(printf '\n\t')"

###############################################################################
# Globals
###############################################################################

_VERSION="1.0.0-alpha"

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Shortcut for testing against the existence of a $debug variable. Primarily
# intended to be used before a printf statement.
#
# Usage:
#   _debug printf "Debug info"
_debug() {
  if [[ "${_use_debug:-"0"}" -eq 1 ]]; then
    printf "ðŸ›  "
    "$@"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n"
  fi
}

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
raw_options="$*"

# Initialize command options and arguments arrays.
#
# These contain any options and arguments that will be used by the commands.
# Commands handle their own argument and option checks using the created arrays.
command_options=()
command_arguments=()
# Initialize $cmd and $_use_debug, which can continue to be blank depending on
# what the program needs.
cmd=""
_use_debug=0

while [ $# -gt 0 ]; do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      cmd="help"
      ;;
    --version)
      cmd="version"
      ;;
    --debug)
      _use_debug=1
      ;;
    -*|--*)
      command_options+=("$opt")
      ;;
    *)
      # The first non-option argument is assumed to be the command name.
      # All subsequent arguments are added to $command_arguments.
      if [[ -n $cmd ]]; then
        command_arguments+=("$opt")
      else
        cmd=$opt
      fi
      ;;
  esac
done

_debug printf "\$cmd: %s\n" "$cmd"
_debug printf "\$raw_options (one per line):\n%s\n" "$raw_options"
_debug printf "\$command_options: %s\n" "${command_options[*]:-}"
_debug printf "\$command_arguments: %s\n" "${command_arguments[*]:-}"

###############################################################################
# Environment
###############################################################################

# $_me
#
# Set to the program's basename.
_me=$(basename "$0")

_debug printf "\$_me: %s\n" "$_me"

###############################################################################
# Load Commands
###############################################################################

# Initialize defined_commands array.
defined_commands=()

# _load_commands()
#
# Loads all of the commands sourced in the environment.
#
# Usage:
#   _load_commands
_load_commands() {
  _debug printf "_load_commands(): entering...\n"
  _debug printf "_load_commands() declare -F:\n%s\n" "$(declare -F)"
  function_list=($(declare -F))
  for c in "${function_list[@]}"
  do
    function_name=$(printf "%s" "$c" | awk '{ print $3 }')
    _debug printf "_load_commands() \$function_name: %s\n" "$function_name"
    if ! ( [[ "$function_name" =~ ^_(.*) ]] || \
           [[ "$function_name" == "desc" ]]
    ); then
      defined_commands+=("$function_name")
    fi
  done
  _debug printf \
    "commands() \$defined_commands:\n%s\n" \
    "${defined_commands[*]:-}"
}

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_main() {
  _debug printf "main(): entering...\n"
  _debug printf "main() \$cmd (upon entering): %s\n" "$cmd"

  # If $cmd is blank, then set to help
  if [[ -z $cmd ]]; then
    cmd="help"
  fi

  # Load all of the commands.
  _load_commands

  # Run the command and pass the command arguments.
  if ( _contains "$cmd" "${defined_commands[*]:-}" ); then
    $cmd "${command_arguments[@]:-}"
  else
    printf "Unknown command: %s\n" "$cmd"
    exit 1
  fi
}

###############################################################################
# Getters
###############################################################################

# _get_command_argument()
#
# Print the value of a command argument at the specified position. This is
# simply an accessor for the command_arguments array.
#
# NOTE: index starts at 1, just like normal bash parameters.
#
# Usage:
#   $(_get_command_argument 1)
_get_command_argument() {
  position="${1:-}"
  if [[ -z "$position" ]]; then
    printf "Error: _get_command_argument(): no value specified.\n"
    exit 1
  elif [[ "$position" -eq 0 ]]; then
    _debug printf "_get_command_option(): Invalid 0 position.\n"
    printf "0 is not valid because arguments start at '1'\n"
    exit 1
  else
    position=$((position - 1))
    printf \
      "%s" \
      "${command_arguments[${position:-}]:-}"
  fi
}

_debug printf \
  "\$(_get_command_argument 1): %s\n" \
  "$(_get_command_argument 1)"

# _get_command_option()
#
# Print the value of a command option at the specified position. This is
# simply an accessor for the command_options array.
#
# NOTE: index starts at 1, just like normal bash parameters.
#
# Usage:
#   $(_get_command_option 1)
_get_command_option() {
  position="${1:-}"
  if [[ -z "$position" ]]; then
    printf "Error: _get_command_option(): no value specified.\n"
    exit 1
  elif [[ "$position" -eq 0 ]]; then
    _debug printf "_get_command_option(): Invalid 0 position.\n"
    printf "0 is not valid because arguments start at '1'\n"
    exit 1
  else
    position=$((position - 1))
    printf \
      "%s" \
      "${command_options[${position:-}]:-}"
  fi
}

_debug printf \
  "\$(_get_command_option 1): %s\n" \
  "$(_get_command_option 1)"

###############################################################################
# Utility Functions
###############################################################################

# _function_exists()
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _contains()
#
# Takes an item and a list and determines whether the list contains the item.
#
# Usage:
#   _contains "$item" "${list[*]}"
_contains() {
  _test_list=(${*:2})
  for _test_element in "${_test_list[@]:-}"
  do
    _debug printf "_contains() \$_test_element: %s\n" "$_test_element"
    if [[ "$_test_element" == "$1" ]]; then
      _debug printf "_contains() match: %s\n" "$1"
      return 0
    fi
  done
  return 1
}

# _commnd_options_include()
#
# Takes a possible command option and determines whether it is included in
# the command option list.
#
# Usage:
#   _command_options_include "--an-option"
_command_options_include() {
  _contains "$1" "${command_options[*]:-}"
}

# _commnd_arguments_include()
#
# Takes a possible command argument and determines whether it is included in
# the command argument list.
#
# Usage:
#   _command_arguments_include "an_argument"
_command_arguments_include() {
  _contains "$1" "${command_arguments[*]:-}"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'EOM'
# some message
# EOM
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z $1 ]] && printf "desc: No command name specified.\n" && exit 1
  if [[ -n ${2:-} ]]; then
    read -d '' "_desc_$1" <<EOM
$2
EOM
    _debug printf "desc() set with argument: _desc_%s\n" "$1"
  else
    read -d '' "_desc_$1"
    _debug printf "desc() set with pipe: _desc_%s\n" "$1"
  fi
  set -e
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  var="_desc_$1"
  if [[ -n ${!var:-} ]]; then
    printf "%s\n" "${!var}"
  else
   printf "No additional information for \`%s\`\n" "$1"
  fi
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc version <<EOM
Usage:
  $_me version
  $_me --version

Display the current program version.

To save you the trouble, the current version is $_VERSION
EOM
version() {
  printf "%s\n" "$_VERSION"
}

# Help ########################################################################

desc help <<EOM
Usage:
  $_me help [<command>]

Display help information for $_me or a specified command
EOM
help() {
  if [[ ${#command_arguments[@]:-} = 0 ]]; then
    cat <<EOM
                                                .___
  ____  ____   _____   _____ _____    ____    __| _/______
_/ ___\/  _ \ /     \ /     \\__  \  /    \  / __ |/  ___/
\  \__(  <_> )  Y Y  \  Y Y  \/ __ \|   |  \/ /_/ |\___ \\
 \___  >____/|__|_|  /__|_|  (____  /___|  /\____ /____  >
     \/            \/      \/     \/     \/      \/    \/

Boilerplate for creating a bash program with commands.

Version: $_VERSION

Usage:
  $_me command [<command-arguments>]

Help:
  $_me help [<command>]

$(commands)
EOM
  else
    _print_desc "$1"
  fi
}

# Command List ################################################################

desc commands <<EOM
Usage:
  $_me commands [--raw]

Display the list of available commands.
EOM
commands() {
  if _command_options_include "--raw"; then
    printf "%s\n" "${defined_commands[@]:-}"
  else
    printf "Available commands:\n"
    printf "  %s\n" "${defined_commands[@]:-}"
  fi
}

###############################################################################
# Commands
# ========.....................................................................
#
# Example command group structure:
#
# desc example ""   - Optional. A short description for the command.
# example() { : }   - The command called by the user.
#
#
# desc example <<EOM
#   Example help text. Options specified with http://docopt.org/
# EOM
# example() {
#   echo "Hello, World!"
# }
#
###############################################################################

# Example Section #############################################################

# --------------------------------------------------------------------- example

desc example <<EOM
Usage:
  $_me example [<name>] [--casual]

Print "Hello, World!"
EOM
example() {
  if ( _command_options_include "--casual" ); then
    greeting="Hi"
  else
    greeting="Hello"
  fi
  name=$(_get_command_argument 1)

  _debug printf "example() \$greeting: %s\n" "$greeting"
  _debug printf "example() \$name: %s\n" "$name"

  if [[ "$name" == "Bill" ]]; then
    printf "%s, William!\n" "$greeting"
  elif [[ -n "$name" ]]; then
    printf "%s, %s!\n" "$greeting" "$name"
  else
    printf "%s, World!\n" "$greeting"
  fi
}

###############################################################################
# Run Program
###############################################################################

# Calling the _main function after everything has been defined.
_main
